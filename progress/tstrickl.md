=Weekly Progress=
**Week 1**: as a preamble to this week I helped to create a sort of foundation such as the gamemanager, object struct, player struct, vector functions, weapon, etc. After which I started focusing on creating a prototype music loop, creating a background sprite, then a debugger (which is buggy at the moment), and finally I have been working on a doubly linked list implementation, which has two seperate structs: doubly node and doubly linked list. The doubly node file is responsible for functions that link nodes together, while the doubly linked list file is supposed to keep track of the head and tail, and remove stuff and change those fields dynamically. Now for the player struct, I imbeded the type object as one of its fields, so that it can be downcasted and upcasted, as to simulated that fact that player IS an object as it derives from object. Anytime you do    
Object* = (Object*)player;, it will work, aswell as the reverse as long as you are careful and make sure you are making the right check precautions: Player* = (Player*)Object; I also think i have just finished the doubly linked list implementation within the main branch, as i have multiple instances of player in a list, and i am loopin throught the list to update them all, though there might be some bugs that need fixing.

**Week 2**: I have been working on a debugger for both the linked list and object in general. the general object debugger is functions, where it reads the passed in object data and prints it to the screen as it changes every frame. The data that is printed groups all of the fields into seperate categories: position, dir, and misc. Next i was finalizing the implementation of a debugger for the lined list. What it does it is creates lines that follow the path of each next node and previous node. the line being drawn from one object to another (represented by periods) is the forward direction in the list, while the commas represent the backwards direction in the list. In order to make this possible, i had to use some principles from geometry and triganometry. First of all, i get the position of the two objects in the linked list on the screen, and calculate the distance between the two. This distance in and of itself is the hypotenuse of the triangle that is made between the object's positions. each period, or comma, to be drawn on the hypotenuse line between the two points form tiny triangles, within the bigger triangle. This is why i can use cos and pythagorean theorem to figure out the position of these points because this triangle is put within the bigger triangle, which makes a simular triangle through the theorem of ANGLE-ANGLE-SIDE. this theorem mean that the smaller triangle and bigger triangle share the same triganometric ratios.

**Week 3**: This week I started working on the component-based architecture within the fever_dream branch. I started of stripping down the object struct into a very simple component. All it has is a name, and an object id. From object two main things derive: components and gameobjects. a gameobject is going to be a "concept" within the scene, of which will have behaviours defined by components. 

Components can be added to gameobjects to add behaviour to them during runtime, due to the fact that the gameobject keeps a linked list of all of the components attached to it. when the gameobject is disabled, so are the components attatched to it. But it is also the case that components individually can be deactivated. To create a gameobject you call GameObjectManagerCreateGameObject(); there are no parameters, as it abstracts everything away from you. to attach a component to a gameobject you call: AttachComponentToGameObject(GameObject* gameObject, ComponentType type); the only parameters you have to pass in are the one that directly relate to the function, that being the gameobject you are attaching a component onto, and the type that the component is going to be. At the moment there are a few component types. There will be a TRANSFORM_COMPONENT, RENDER_COMPONENT, COLLIDER_COMPONENT, PLAYER_CONTROLLER_COMPONENT, etc. 

If I want to create a player in the scene, understanding what the player is made up of, and all of its behaviours, I would attach to the player gameobject a TRANSFORM_COMPONENT, to add behaviour of position. I would add COLLIDER_COMPONENT, so that it can collide. I would add RENDER_COMPONENT so that it could be rendered onto the screen. And finally I would add PLAYER_CONTROLLER_COMPONENT, to control and maintain cohesively all the other components, and make them work together as a whole. 

Other functions I added, in order for components to communicate with eachother are: GetGameObjectOfComponent(Component* component). This gets the gameobject, that the given component is attached to. Also: GameObjectGetComponentOfType(GameObject* gameObject, ComponentType type). This tries to find if a component of a given type is attached to the given object. And GameObjectGetComponentFromComponent(Component* component, ComponentType type). This gets a component by type in the current gameobject that the component you are callilng from is attached to.
