=Weekly Progress=
**Week 1**: as a preamble to this week I helped to create a sort of foundation such as the gamemanager, object struct, player struct, vector functions, weapon, etc. After which I started focusing on creating a prototype music loop, creating a background sprite, then a debugger (which is buggy at the moment), and finally I have been working on a doubly linked list implementation, which has two seperate structs: doubly node and doubly linked list. The doubly node file is responsible for functions that link nodes together, while the doubly linked list file is supposed to keep track of the head and tail, and remove stuff and change those fields dynamically. Now for the player struct, I imbeded the type object as one of its fields, so that it can be downcasted and upcasted, as to simulated that fact that player IS an object as it derives from object. Anytime you do    
Object* = (Object*)player;, it will work, aswell as the reverse as long as you are careful and make sure you are making the right check precautions: Player* = (Player*)Object; I also think i have just finished the doubly linked list implementation within the main branch, as i have multiple instances of player in a list, and i am loopin throught the list to update them all, though there might be some bugs that need fixing.

**Week 2**: I have been working on a debugger for both the linked list and object in general. the general object debugger is functions, where it reads the passed in object data and prints it to the screen as it changes every frame. The data that is printed groups all of the fields into seperate categories: position, dir, and misc. Next i was finalizing the implementation of a debugger for the lined list. What it does it is creates lines that follow the path of each next node and previous node. the line being drawn from one object to another (represented by periods) is the forward direction in the list, while the commas represent the backwards direction in the list. In order to make this possible, i had to use some principles from geometry and triganometry. First of all, i get the position of the two objects in the linked list on the screen, and calculate the distance between the two. This distance in and of itself is the hypotenuse of the triangle that is made between the object's positions. each period, or comma, to be drawn on the hypotenuse line between the two points form tiny triangles, within the bigger triangle. This is why i can use cos and pythagorean theorem to figure out the position of these points because this triangle is put within the bigger triangle, which makes a simular triangle through the theorem of ANGLE-ANGLE-SIDE. this theorem mean that the smaller triangle and bigger triangle share the same triganometric ratios.

**Week 3**: This week I started working on the component-based architecture within the fever_dream branch. I started of stripping down the object struct into a very simple component. All it has is a name, and an object id. From object two main things derive: components and gameobjects. a gameobject is going to be a "concept" within the scene, of which will have behaviours defined by components. 

Components can be added to gameobjects to add behaviour to them during runtime, due to the fact that the gameobject keeps a linked list of all of the components attached to it. when the gameobject is disabled, so are the components attatched to it. But it is also the case that components individually can be deactivated. To create a gameobject you call GameObjectManagerCreateGameObject(); there are no parameters, as it abstracts everything away from you. to attach a component to a gameobject you call: AttachComponentToGameObject(GameObject* gameObject, ComponentType type); the only parameters you have to pass in are the one that directly relate to the function, that being the gameobject you are attaching a component onto, and the type that the component is going to be. At the moment there are a few component types. There will be a TRANSFORM_COMPONENT, RENDER_COMPONENT, COLLIDER_COMPONENT, PLAYER_CONTROLLER_COMPONENT, etc. 

If I want to create a player in the scene, understanding what the player is made up of, and all of its behaviours, I would attach to the player gameobject a TRANSFORM_COMPONENT, to add behaviour of position. I would add COLLIDER_COMPONENT, so that it can collide. I would add RENDER_COMPONENT so that it could be rendered onto the screen. And finally I would add PLAYER_CONTROLLER_COMPONENT, to control and maintain cohesively all the other components, and make them work together as a whole. 

Other functions I added, in order for components to communicate with eachother are: GetGameObjectOfComponent(Component* component). This gets the gameobject, that the given component is attached to. Also: GameObjectGetComponentOfType(GameObject* gameObject, ComponentType type). This tries to find if a component of a given type is attached to the given object. And GameObjectGetComponentFromComponent(Component* component, ComponentType type). This gets a component by type in the current gameobject that the component you are callilng from is attached to.

**Week 4**
This week i was cleaning up doubly linked list in fever_dream and started development and a singly linked list. Within this branch i also started creating the transform and render component. The transform component has a position & rotation that can be manipulated by the transform manager given the transform component that is desired to have it's position changed. So given a player controller component, it would be a controller between the transform component, render component, and collision component. the player controller component can use the game object manager functions to get a component attacked to the current game object, and then call the transform system functions to manipulate the transform component attached to the gameobject of the player controller component. As for the render component, it is a container that depends on the transform component. It has fields for the region and texture. when the render components update function is called, it renders that region at the position of the gameobjects transform component. I further sepearted the declaration from the implementations in order to avoid compiler loops. for example, the transform component has a header file that declares all the fields of the transform. there is then a declaration for the transform manager that will have fields for holding a list of transform components, and declarations for doing managerial operations on the list of transform components. There is then a c transform_manager.c file in order to implement the declarations defined in transform_manager.h. the c file is then included into the game manager. This is neccessary in order to allow multiple other files to use the transform manager without the risk of getting stuck in an include loop during precompilation.

**Week 5**
This week, within the project, I have been working specifically on extending the transform component, the render component, and finishing off by creating declarations for the queue and stack. What I am planning for the architecture is for multiple components to be able to access each other, specifically if they are attached to the same game object. This is needed because the render component needs to know where it is positioned. To do this, the render component will request the transform component that is affiliated with the same game object of the renderer. once it has the position, it will be able to render the image at the position defined within the transform component. Finally, I have been cleaning up the doubly linked list as it is a bit messy. I am doing this because it is in preparation for the stack and queue implementations. For those, I started off with the declarations. So far i have declared, for the stack: Stack, Destack, & peak. For the Queue: Enqueue, Dequeue, Peak. The functions are for adding nodes to the queue, or stack, removing, and taking a peek as to what the current selected node is. At the moment, the getcomponentfrom component function isn't working, so the components can't access other components at the moment. This is something that needs to be fixed quickly, to allow for more complex behaviour. Some more goals that I have in mind is to give a reference to the parent of a child to the child itself, to keep it more efficient and to not rely on searching every single object within the scene to figure out if a object is a child of a single object.

**Week 6**
This week, I finally have reached a workable version of the component based archicture. A GameObject represents a concept within in a scene. Though it doesn't do anything on it's own, it is a container for components (which are simply behaviours to be attatched to gameobjects). I define behaviour as the change of data over time. What components serve to do is change data over time, therefore, they are behavioural objects. Game object is a container for these components. We attach components to game objects in order to attach given behaviours to that gameobject. For example, I can create a player gameobject in the scene. This object is merely supposed to represent a given single "concept." This gameobject doesn't do anything though because we didn't give it behaviour. This is where the components come in. If say, I want the player gameobject to exhibit the behaviour of being able to collide with other gameobjects, I would attach a collider component to the player game object. This will immediately apply the behaviour of collision onto the player. So now, by simply attaching a collision component to the player gameobject, it will immediately be able to collide with other gameobjects that have a hitbox. These components can be very simple, or more complex in nature. For example, there is a component called transform. All this component does is give the given gameobject that it is attached to a position & rotation. Future component ideas could be a weapon component. This component, when attached to a gameobject, immediatly allows that gameobject to shoot. This modular system for attaching components, which are behaviours to gameobjects, allows those gameobjects to exhibit those behaviours, is very useful. All you have to do is create a component once, and you are immediately able to mix and match and create more complex behaviours. One way that this is shown for example is the dynamic between enemies and players. Both enemies and players are very similar in many ways. Both enemy and player have a position and rotation in the scene, so they would both have a transform component attatched to them. Both can shoot, so both would have a weapon component attatched to them. One difference though, is who is controlling it. For the player, the input is controlled by an external device. For the enemy, the input is controlled by the CPU. what we would do is then attach the component for external output control to the player, and attach the component for CPU control to the enemy. and just like that, we were able to make completely different objects by attaching components in respect to how we want the game object to behave. The benefit of this is that we coded the transform and weapon compoent just once, and yet we were able to make two completely different objects, of which exhibit different behaviours, depending on what components are attached to what. The only difference at the moement between the player and enemy object is that player has an external input control component, and the enemy has a CPU control component. We were able to make two similar objects, that act slightly differently, by just attaching simular components, but also attaching their own respective components.